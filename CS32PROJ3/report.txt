Classes design:
        For the board class, I created 4 private data members. An int that holds the number of holes that the board has, an int that holds that initial beans per holes, and two int pointers for the north and south holes. To represent the north and south sides, I used a dynamically allocated array of size m_Holes. Since I did that, I had to write my own copy constructor, assignment operator, and destructor. The initial beans per hole data member is mainly used for constructing a board object and the holes data member was usually anytime I had to iterate through the arrays.
        For the player class, I created a string data member that represented the name of the player. I implemented the player class constructor to initialize this. I also implemented the is iterative function to return false and only changed it for the HumanPlayer class. The only derived class that had any private data members or functions was the Smart Player class. I created a function with extra arguments for int value, bestHole, and parameter for ending after 5 seconds. The function uses the minimax algorithm to find the best move. It passed bestHole by reference so I call this function in the choseHole function for smartPlayer and then just return bestHole.
        For the game class, I had 4 private data member. Two player pointers for north and south, a board object and a Side object to keep track of the current side. The player pointers were used to sow the board because they use the choose move function and depending on the type of player each choicemove does something different. The board keeps track of the holes and beans of the players and is used to display what's happening on the screen. The current side is used to keep track of whose turn it is.


SmartPlayer Description:
        The heuristic is used was south’s pot minus north’s pot. So a high number is good for south and a low number is good for north. As I explained earlier, I used a helper private member function that had more arguments and could keep track of more things. The function took in a board that was marked const and side as well as a bestHole and value integer. I made a copy of the board so that it would not affect the actual board. Then I had a base case where that check if either side had no more beans in play, if one side didn’t then I moved any leftover beans to their respected pot. After that depending on what side called the function, I would compared the two pots and assign either a high value if south won or a low value if north won and zero for a tie. The next thing I did was create a condition for returning early if the timer class reached a certain point so that it would not exceed 5 seconds. For the main body of the function, I loop through the number of holes and for each I “make” the move on the copied board, check for capture or landing in own pot, and then recursively call the function again but on the new board with the move that had just been made and a new v2 value argument. After I compare v2 to value and if its better (lower for north and Higher if its south) then I change value to v2 and besthole to i.


Bugs and Issues:
        The main bug I had was initializing the value parameter, at first I had it unitalized and then tried 0. In both of these cases, it messed with the comparison at the end of the function which decides whether to make besthole = i. For example, when I had it initialized to 0 this works fine for south because any bigger value would be better and therefore the condition would be satisfied but for north since its comparing to numbers smaller than it it didn’t work. If one node of the tree was 5 and another was 2 we want the one that's lower which is 2 but since I had value set at 0, both of these were more than zero so the condition never was satisfied and besthole didn’t ever change.










Pseudocode:
Board:: sow function
Determine side
        Check if hole is valid
        While number of beans in the hole is not empty
                If side is south
                For number of holes
                If ends in your pot
                Add to pot and subtract from number of beans
                Endhole is pot
                Endside is your side unless more beans are left
                Switch sides if thats the case
                Else
                Just add to hole and subtract like normal
                If run out of beans
                        Determine endhole and break
                If side is north
                Same process but loop starting at the number of holes down to 0
If other Side
        Same process but reversed order
        
HumanPlayer:: chooseMove
Prompt to pick a move
        While(true)
                Cin move
                If the move is valid
                Return move
                Else
                Reprompt 
BadPlayer:: chooseMove 
        For number of holes 
        If the hole has postive number of beans
        Return that hole


SmartPlayer:: miniMax
Make copy of the board
If the game is over
Sweep any remaining beans
Determine Winner
        Set value depending on winner (1000000 or -1000000) 
Return besthole as -1
If timer runs out
        Compare pots and set value to difference
        Return besthole as -1


Initialize value depending on which side
For the number of holes
Skip any empty holes
Make the move on the copy board        
Check for landing in own pot
Check for capture
Call minimax again with new value argument
Set copy back to original board
Compare new value with current value
        Set besthole to i
        Set value to new value
Return besthole


SmartPlayer:: chooseMove
Call minmax
Return besthole
Game:: Move()
If game is over
        Return false
Determine side
Make the move for that sides player
Check if no beans remaining 
        Sweep beans
While endside is your side and endhole is pot
        Display
        Move agian
Check for capture
        Move beans accordingly
Switch sides
Return true


                








BOARD TEST CASES:
Board b(3, 2);
    assert(b.holes() == 3  &&  b.totalBeans() == 12  &&
           b.beans(SOUTH, POT) == 0  &&  b.beansInPlay(SOUTH) == 6); //check hole,totalbeans, and beansinplay function and that pot has no beans
    b.setBeans(SOUTH, 1, 1);
    b.moveToPot(SOUTH, 2, SOUTH);
    
    assert(b.totalBeans() == 11  &&  b.beans(SOUTH, 1) == 1  && //check that setbeans and move to pot function work properly
           b.beans(SOUTH, 2) == 0  &&  b.beans(SOUTH, POT) == 2  &&
           b.beansInPlay(SOUTH) == 3);
    Side es;
    int eh;
    b.sow(SOUTH, 3, es, eh);


    assert(es == NORTH  &&  eh == 3  &&  b.beans(SOUTH, 3) == 0  && //checks sow function (once around)
           b.beans(NORTH, 3) == 3  &&  b.beans(SOUTH, POT) == 3  &&
           b.beansInPlay(SOUTH) == 1  &&  b.beansInPlay(NORTH) == 7);
    
    Board b2(3,7);
    Side es2;
    int eh2;
    b2.sow(NORTH,2 , es2, eh2);
    
    assert(es2 == NORTH  &&  eh2 == 2  &&  b2.beans(NORTH, 2) == 1  && //checks sow function (multiple times)
           b2.beans(NORTH, 3) == 8  &&  b2.beans(NORTH, POT) == 1  && b2.beans(SOUTH, POT)==0 && b2.beans(NORTH,1)== 8 &&
           b2.beansInPlay(SOUTH) == 24  &&  b2.beansInPlay(NORTH) == 17);
    
    assert(b2.sow(NORTH,0,es2,eh2)==false); //checks that pot is not valid hole
    
    Board b5(3,7);
    Side es3;
    int eh3;
    b5.sow(SOUTH,2 , es3, eh3); //checks multiple times for south
    
    assert(es3 == SOUTH  &&  eh3 == 2  &&  b5.beans(SOUTH, 2) == 1  && //checks sow function (multiple times) for south
           b5.beans(SOUTH, 3) == 8  &&  b5.beans(SOUTH, POT) == 1  && b5.beans(NORTH, POT)==0 && b5.beans(SOUTH,1)== 8 &&
           b5.beansInPlay(NORTH) == 24  &&  b5.beansInPlay(SOUTH) == 17);
    


    Board b3(3, 2);
    Side Es;
    int Eh;
    b3.sow(SOUTH, 2, Es, Eh); //edge case where last bean lands in your own pot
    assert(Es==SOUTH && Eh == 0 && b3.beans(SOUTH, POT)==1 && b3.beansInPlay(SOUTH)==5);
    
    Board b4(3, 2); // lands in pot edge case for north
    Side Es3;
    int Eh3;
    b3.sow(NORTH, 2, Es3, Eh3); //edge case where last bean lands in your own pot
    assert(Es3==NORTH && Eh3 == 0 && b3.beans(NORTH, POT)==1 && b3.beansInPlay(NORTH)==5);


GAME TEST CASES:
 BadPlayer bp1("Bart");   //manually see that play and display function work (show the progression of the board, alternate turns and make moves to completion)
    BadPlayer bp2("Homer");
    Board b(3, 0);
    b.setBeans(SOUTH, 1, 2);
    b.setBeans(NORTH, 2, 1);
    b.setBeans(NORTH, 3, 2);
    Game g(b, &bp1, &bp2);
    bool over;
    bool hasWinner;
    Side winner;
    g.play();


BadPlayer bp1("Bart");
    BadPlayer bp2("Homer");
    Board b(3, 0);
    b.setBeans(SOUTH, 1, 2);
    b.setBeans(NORTH, 2, 1);
    b.setBeans(NORTH, 3, 2);
    
BadPlayer bp1("Bart"); //set up board for “capture” make sure it works
    HumanPlayer bp2("Homer");
    Board b(3, 0);
    b.setBeans(SOUTH, 1, 2);
    b.setBeans(NORTH, 2, 1);
    b.setBeans(NORTH, 3, 2);
    b.setBeans(SOUTH, 2, 7);
    Game g(b, &bp2, &bp1);
    bool over;
    bool hasWinner;
    Side winner;
    g.play(); //human moves first and picks capture, makes sure game handles situation correctly


    Game g(b, &bp1, &bp2);
    bool over;
    bool hasWinner;
    Side winner;
   
    g.status(over, hasWinner, winner); // create a game and makes sure its handling the board correctly
       assert(!over && g.beans(NORTH, POT) == 0 && g.beans(SOUTH, POT) == 0 &&
           g.beans(NORTH, 1) == 0 && g.beans(NORTH, 2) == 1 && g.beans(NORTH, 3) == 2 &&
           g.beans(SOUTH, 1) == 2 && g.beans(SOUTH, 2) == 0 && g.beans(SOUTH, 3) == 0);
    g.move();
    g.status(over, hasWinner, winner);
    assert(!over && g.beans(NORTH, POT) == 0 && g.beans(SOUTH, POT) == 3 &&
           g.beans(NORTH, 1) == 0 && g.beans(NORTH, 2) == 1 && g.beans(NORTH, 3) == 0 &&
           g.beans(SOUTH, 1) == 0 && g.beans(SOUTH, 2) == 1 && g.beans(SOUTH, 3) == 0);
        g.move();
        g.status(over, hasWinner, winner);
    assert(!over && g.beans(NORTH, POT) == 0 && g.beans(SOUTH, POT) == 3 &&
           g.beans(NORTH, 1) == 1 && g.beans(NORTH, 2) == 0 && g.beans(NORTH, 3) == 0 &&
           g.beans(SOUTH, 1) == 0 && g.beans(SOUTH, 2) == 1 && g.beans(SOUTH, 3) == 0);
    g.move();
       g.status(over, hasWinner, winner);
    assert(!over && g.beans(NORTH, POT) == 0 && g.beans(SOUTH, POT) == 3 &&
           g.beans(NORTH, 1) == 1 && g.beans(NORTH, 2) == 0 && g.beans(NORTH, 3) == 0 &&
           g.beans(SOUTH, 1) == 0 && g.beans(SOUTH, 2) == 0 && g.beans(SOUTH, 3) == 1);
    g.move();
       g.status(over, hasWinner, winner);
    cout<<g.beans(NORTH, POT)<<endl<<g.beans(SOUTH, POT)<<g.beans(SOUTH, 3);
    assert(over && g.beans(NORTH, POT) == 1 && g.beans(SOUTH, POT) == 4 &&
           g.beans(NORTH, 1) == 0 && g.beans(NORTH, 2) == 0 && g.beans(NORTH, 3) == 0 &&
           g.beans(SOUTH, 1) == 0 && g.beans(SOUTH, 2) == 0 && g.beans(SOUTH, 3) == 0);
    assert(hasWinner && winner == SOUTH);


PLAYER TEST CASES:

Smart Player:
 Board b(3, 0);
    b.setBeans(SOUTH, 3, 1); //board set up so that one move will result in a bigger and faster win
    b.setBeans(SOUTH,2, 0);
    b.setBeans(SOUTH, 1, 1);
    b.setBeans(NORTH, 3, 1);
    SmartPlayer sp("Lisa");
    assert(sp.chooseMove(b, SOUTH)==3);  //check that smart player choose correct move on small scale


Board b2(3, 0);
    b2.setBeans(NORTH, 3, 1); //set up board so that one move will result in bigger and faster win
    b2.setBeans(NORTH,2, 0);
    b2.setBeans(NORTH, 1, 7);
    b2.setBeans(SOUTH, 3, 1);
    SmartPlayer sp2("Lisa");
    assert(sp2.chooseMove(b2, NORTH)==1); //check that smart player chooses the correct move for north too on small scale






Human and Bad Player:
HumanPlayer hp("Marge");
    assert(hp.name() == "Marge"  &&  hp.isInteractive()); //names and interactive status 
    BadPlayer bp("Homer");
    assert(bp.name() == "Homer"  &&  !bp.isInteractive());
    SmartPlayer sp("Lisa");
    assert(sp.name() == "Lisa"  &&  !sp.isInteractive());
    Board b(2, 2);
    b.setBeans(SOUTH, 2, 0);
    cout << "=========" << endl;
    int n = hp.chooseMove(b, SOUTH); //repromts human until picks valid move
    cout << "=========" << endl;
    assert(n == 1  ||  n == 3);
    n = bp.chooseMove(b, SOUTH); 
    assert(n == 1  ||  n == 3);   //check that bad player chooses valid move